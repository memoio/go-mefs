package keeper

import (
	"context"
	"log"
	"strconv"
	"strings"

	ds "github.com/memoio/go-mefs/source/go-datastore"
	"github.com/memoio/go-mefs/utils"
	"github.com/memoio/go-mefs/utils/metainfo"
	"github.com/memoio/go-mefs/utils/pos"
)

// handlePosAdd handles block_meta which is generated by pos
// value is
func (k *Info) handlePosAdd(km *metainfo.KeyMeta, metaValue []byte, from string) {
	// add provider to upkeeping if it is not in upkeeping
	err := k.ukpManager.ukAddProvider(pos.GetPosId(), from, pos.PosSkStr)
	if err != nil {
		log.Println("handlePosAdd err:", err)
	}
	if from != km.GetMid() {
		log.Println("handlePosAdd error! from!=km.mid")
	}
	blocks := strings.Split(string(metaValue), metainfo.DELIMITER)
	for _, boff := range blocks {
		//保存在本地
		blockID, off, err := utils.SplitIndex(boff)
		if err != nil {
			log.Println("SplitIndex err:", err)
			continue
		}

		kmBlock, err := metainfo.NewKeyMeta(blockID, metainfo.Pos)
		if err != nil {
			log.Println(err)
			return
		}
		pidAndOffset := from + metainfo.DELIMITER + strconv.Itoa(off)
		err = k.ds.PutKey(context.Background(), kmBlock.ToString(), []byte(pidAndOffset), "local")
		if err != nil {
			log.Println(err)
			return
		}

		//保存到内存
		bm, err := metainfo.GetBlockMeta(blockID)
		if err != nil {
			log.Println(err)
			return
		}
		err = k.addBlockMeta(bm.GetQid(), from, blockID, off)
		if err != nil {
			log.Println(err)
			return
		}
	}
}

// handlePosDelete() handles block_meta deletion
func (k *Info) handlePosDelete(km *metainfo.KeyMeta, metaValue []byte, from string) {
	deleteBlocks := strings.Split(string(metaValue), metainfo.DELIMITER)
	if from != km.GetMid() {
		log.Println("handlePosDelete error! from and km.mid are: ", from, km.GetMid())
	}
	for _, blockID := range deleteBlocks {
		//先删除本地信息
		kmBlock, err := metainfo.NewKeyMeta(blockID, metainfo.BlockPos)
		if err != nil {
			log.Println(err)
			return
		}
		err = k.ds.DeleteKey(context.Background(), kmBlock.ToString(), "local")
		if err != nil && err != ds.ErrNotFound {
			log.Println(err)
			return
		}
		//再删除内存中信息
		bm, err := metainfo.GetBlockMeta(blockID)
		if err != nil {
			log.Println(err)
			return
		}
		k.deleteBlockMeta(bm.GetQid(), blockID)
	}
}
