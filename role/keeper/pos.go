package keeper

import (
	"fmt"
	"strings"

	ds "github.com/memoio/go-mefs/source/go-datastore"
	dht "github.com/memoio/go-mefs/source/go-libp2p-kad-dht"
	"github.com/memoio/go-mefs/utils/pos"

	"github.com/memoio/go-mefs/utils/metainfo"
)

// handlePosAdd handles block_meta which is generated by pos
func handlePosAdd(km *metainfo.KeyMeta, metaValue, from string) {
	// add provider to upkeeping if it is not in upkeeping
	err := ukAddProvider(pos.PosId, from, pos.PosSk)
	if err != nil {
		fmt.Println("handlePosAdd err:", err)
	}
	if from != km.GetMid() {
		fmt.Println("handlePosAdd error! from!=km.mid")
	}
	blocks := strings.Split(metaValue, metainfo.DELIMITER)
	for _, blockID := range blocks {
		//保存在本地
		kmBlock, err := metainfo.NewKeyMeta(blockID, metainfo.Local, metainfo.SyncTypeBlock)
		if err != nil {
			fmt.Println(err)
			return
		}
		pidAndOffset := from + metainfo.DELIMITER + "255"
		err = localNode.Routing.(*dht.IpfsDHT).CmdPutTo(kmBlock.ToString(), pidAndOffset, "local")
		if err != nil {
			fmt.Println(err)
			return
		}

		//保存到内存
		bm, err := metainfo.GetBlockMeta(blockID)
		if err != nil {
			fmt.Println(err)
			return
		}
		err = doAddBlocktoLedger(from, bm.GetUid(), blockID, 255)
		if err != nil {
			fmt.Println(err)
			return
		}
	}
}

// handlePosDelete() handles block_meta deletion
func handlePosDelete(km *metainfo.KeyMeta, metaValue, from string) {
	deleteBlocks := strings.Split(metaValue, metainfo.DELIMITER)
	if from != km.GetMid() {
		fmt.Println("handlePosDelete error! from!=km.mid")
	}
	for _, blockID := range deleteBlocks {
		//先删除本地信息
		kmBlock, err := metainfo.NewKeyMeta(blockID, metainfo.Local, metainfo.SyncTypeBlock)
		if err != nil {
			fmt.Println(err)
			return
		}
		err = localNode.Routing.(*dht.IpfsDHT).DeleteLocal(kmBlock.ToString())
		if err != nil && err != ds.ErrNotFound {
			fmt.Println(err)
			return
		}
		//再删除内存中信息
		bm, err := metainfo.GetBlockMeta(blockID)
		if err != nil {
			fmt.Println(err)
			return
		}
		deleteBlockInLedger(from, bm)
	}
}
