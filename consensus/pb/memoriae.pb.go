// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: memoriae.proto

package memoriae_pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/gogo/protobuf/types"

import time "time"

import github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type TxType int32

const (
	TxType_KV      TxType = 0
	TxType_ChalReq TxType = 1
	TxType_ChalRes TxType = 2
)

var TxType_name = map[int32]string{
	0: "KV",
	1: "ChalReq",
	2: "ChalRes",
}
var TxType_value = map[string]int32{
	"KV":      0,
	"ChalReq": 1,
	"ChalRes": 2,
}

func (x TxType) String() string {
	return proto.EnumName(TxType_name, int32(x))
}
func (TxType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_memoriae_1593a725c8671815, []int{0}
}

type KVType int32

const (
	KVType_Default   KVType = 0
	KVType_BlockMeta KVType = 1
)

var KVType_name = map[int32]string{
	0: "Default",
	1: "BlockMeta",
}
var KVType_value = map[string]int32{
	"Default":   0,
	"BlockMeta": 1,
}

func (x KVType) String() string {
	return proto.EnumName(KVType_name, int32(x))
}
func (KVType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_memoriae_1593a725c8671815, []int{1}
}

type PkType int32

const (
	PkType_Secp256k1 PkType = 0
	PkType_Ed25519   PkType = 1
)

var PkType_name = map[int32]string{
	0: "Secp256k1",
	1: "Ed25519",
}
var PkType_value = map[string]int32{
	"Secp256k1": 0,
	"Ed25519":   1,
}

func (x PkType) String() string {
	return proto.EnumName(PkType_name, int32(x))
}
func (PkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_memoriae_1593a725c8671815, []int{2}
}

type Tx struct {
	Payload              []byte   `protobuf:"bytes,1,opt,name=Payload,proto3" json:"Payload,omitempty"`
	Typ                  TxType   `protobuf:"varint,2,opt,name=Typ,proto3,enum=memoriae_pb.TxType" json:"Typ,omitempty"`
	Signature            []byte   `protobuf:"bytes,3,opt,name=Signature,proto3" json:"Signature,omitempty"`
	PubKey               []byte   `protobuf:"bytes,4,opt,name=PubKey,proto3" json:"PubKey,omitempty"`
	KeyType              PkType   `protobuf:"varint,5,opt,name=KeyType,proto3,enum=memoriae_pb.PkType" json:"KeyType,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tx) Reset()         { *m = Tx{} }
func (m *Tx) String() string { return proto.CompactTextString(m) }
func (*Tx) ProtoMessage()    {}
func (*Tx) Descriptor() ([]byte, []int) {
	return fileDescriptor_memoriae_1593a725c8671815, []int{0}
}
func (m *Tx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Tx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tx.Merge(dst, src)
}
func (m *Tx) XXX_Size() int {
	return m.Size()
}
func (m *Tx) XXX_DiscardUnknown() {
	xxx_messageInfo_Tx.DiscardUnknown(m)
}

var xxx_messageInfo_Tx proto.InternalMessageInfo

func (m *Tx) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Tx) GetTyp() TxType {
	if m != nil {
		return m.Typ
	}
	return TxType_KV
}

func (m *Tx) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Tx) GetPubKey() []byte {
	if m != nil {
		return m.PubKey
	}
	return nil
}

func (m *Tx) GetKeyType() PkType {
	if m != nil {
		return m.KeyType
	}
	return PkType_Secp256k1
}

type KVPayload struct {
	Key                  []byte   `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Value                []byte   `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
	Typ                  KVType   `protobuf:"varint,3,opt,name=Typ,proto3,enum=memoriae_pb.KVType" json:"Typ,omitempty"`
	Sign                 [][]byte `protobuf:"bytes,4,rep,name=Sign" json:"Sign,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KVPayload) Reset()         { *m = KVPayload{} }
func (m *KVPayload) String() string { return proto.CompactTextString(m) }
func (*KVPayload) ProtoMessage()    {}
func (*KVPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_memoriae_1593a725c8671815, []int{1}
}
func (m *KVPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *KVPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVPayload.Merge(dst, src)
}
func (m *KVPayload) XXX_Size() int {
	return m.Size()
}
func (m *KVPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_KVPayload.DiscardUnknown(m)
}

var xxx_messageInfo_KVPayload proto.InternalMessageInfo

func (m *KVPayload) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *KVPayload) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *KVPayload) GetTyp() KVType {
	if m != nil {
		return m.Typ
	}
	return KVType_Default
}

func (m *KVPayload) GetSign() [][]byte {
	if m != nil {
		return m.Sign
	}
	return nil
}

type ChallengeRequest struct {
	ChallengerPrivateKey    string   `protobuf:"bytes,1,opt,name=ChallengerPrivateKey,proto3" json:"ChallengerPrivateKey,omitempty"`
	AcceptChallengerAddress string   `protobuf:"bytes,2,opt,name=AcceptChallengerAddress,proto3" json:"AcceptChallengerAddress,omitempty"`
	DataPath                string   `protobuf:"bytes,3,opt,name=DataPath,proto3" json:"DataPath,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *ChallengeRequest) Reset()         { *m = ChallengeRequest{} }
func (m *ChallengeRequest) String() string { return proto.CompactTextString(m) }
func (*ChallengeRequest) ProtoMessage()    {}
func (*ChallengeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_memoriae_1593a725c8671815, []int{2}
}
func (m *ChallengeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChallengeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChallengeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ChallengeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChallengeRequest.Merge(dst, src)
}
func (m *ChallengeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ChallengeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ChallengeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ChallengeRequest proto.InternalMessageInfo

func (m *ChallengeRequest) GetChallengerPrivateKey() string {
	if m != nil {
		return m.ChallengerPrivateKey
	}
	return ""
}

func (m *ChallengeRequest) GetAcceptChallengerAddress() string {
	if m != nil {
		return m.AcceptChallengerAddress
	}
	return ""
}

func (m *ChallengeRequest) GetDataPath() string {
	if m != nil {
		return m.DataPath
	}
	return ""
}

type ChallengeResult struct {
	ChallengerID         string    `protobuf:"bytes,1,opt,name=ChallengerID,proto3" json:"ChallengerID,omitempty"`
	AcceptChallengerID   string    `protobuf:"bytes,2,opt,name=AcceptChallengerID,proto3" json:"AcceptChallengerID,omitempty"`
	UserID               string    `protobuf:"bytes,3,opt,name=UserID,proto3" json:"UserID,omitempty"`
	Proof                string    `protobuf:"bytes,4,opt,name=Proof,proto3" json:"Proof,omitempty"`
	Success              bool      `protobuf:"varint,5,opt,name=Success,proto3" json:"Success,omitempty"`
	Blocks               []string  `protobuf:"bytes,6,rep,name=Blocks" json:"Blocks,omitempty"`
	Random               int32     `protobuf:"varint,7,opt,name=Random,proto3" json:"Random,omitempty"`
	Time                 time.Time `protobuf:"bytes,8,opt,name=Time,stdtime" json:"Time"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ChallengeResult) Reset()         { *m = ChallengeResult{} }
func (m *ChallengeResult) String() string { return proto.CompactTextString(m) }
func (*ChallengeResult) ProtoMessage()    {}
func (*ChallengeResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_memoriae_1593a725c8671815, []int{3}
}
func (m *ChallengeResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChallengeResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChallengeResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ChallengeResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChallengeResult.Merge(dst, src)
}
func (m *ChallengeResult) XXX_Size() int {
	return m.Size()
}
func (m *ChallengeResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ChallengeResult.DiscardUnknown(m)
}

var xxx_messageInfo_ChallengeResult proto.InternalMessageInfo

func (m *ChallengeResult) GetChallengerID() string {
	if m != nil {
		return m.ChallengerID
	}
	return ""
}

func (m *ChallengeResult) GetAcceptChallengerID() string {
	if m != nil {
		return m.AcceptChallengerID
	}
	return ""
}

func (m *ChallengeResult) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *ChallengeResult) GetProof() string {
	if m != nil {
		return m.Proof
	}
	return ""
}

func (m *ChallengeResult) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *ChallengeResult) GetBlocks() []string {
	if m != nil {
		return m.Blocks
	}
	return nil
}

func (m *ChallengeResult) GetRandom() int32 {
	if m != nil {
		return m.Random
	}
	return 0
}

func (m *ChallengeResult) GetTime() time.Time {
	if m != nil {
		return m.Time
	}
	return time.Time{}
}

type Payment struct {
	StartTime            time.Time `protobuf:"bytes,1,opt,name=StartTime,stdtime" json:"StartTime"`
	EndTime              time.Time `protobuf:"bytes,2,opt,name=EndTime,stdtime" json:"EndTime"`
	Sum                  uint64    `protobuf:"varint,3,opt,name=sum,proto3" json:"sum,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Payment) Reset()         { *m = Payment{} }
func (m *Payment) String() string { return proto.CompactTextString(m) }
func (*Payment) ProtoMessage()    {}
func (*Payment) Descriptor() ([]byte, []int) {
	return fileDescriptor_memoriae_1593a725c8671815, []int{4}
}
func (m *Payment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Payment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Payment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Payment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payment.Merge(dst, src)
}
func (m *Payment) XXX_Size() int {
	return m.Size()
}
func (m *Payment) XXX_DiscardUnknown() {
	xxx_messageInfo_Payment.DiscardUnknown(m)
}

var xxx_messageInfo_Payment proto.InternalMessageInfo

func (m *Payment) GetStartTime() time.Time {
	if m != nil {
		return m.StartTime
	}
	return time.Time{}
}

func (m *Payment) GetEndTime() time.Time {
	if m != nil {
		return m.EndTime
	}
	return time.Time{}
}

func (m *Payment) GetSum() uint64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

func init() {
	proto.RegisterType((*Tx)(nil), "memoriae_pb.Tx")
	proto.RegisterType((*KVPayload)(nil), "memoriae_pb.KVPayload")
	proto.RegisterType((*ChallengeRequest)(nil), "memoriae_pb.ChallengeRequest")
	proto.RegisterType((*ChallengeResult)(nil), "memoriae_pb.ChallengeResult")
	proto.RegisterType((*Payment)(nil), "memoriae_pb.Payment")
	proto.RegisterEnum("memoriae_pb.TxType", TxType_name, TxType_value)
	proto.RegisterEnum("memoriae_pb.KVType", KVType_name, KVType_value)
	proto.RegisterEnum("memoriae_pb.PkType", PkType_name, PkType_value)
}
func (m *Tx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tx) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMemoriae(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	if m.Typ != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMemoriae(dAtA, i, uint64(m.Typ))
	}
	if len(m.Signature) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMemoriae(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if len(m.PubKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMemoriae(dAtA, i, uint64(len(m.PubKey)))
		i += copy(dAtA[i:], m.PubKey)
	}
	if m.KeyType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMemoriae(dAtA, i, uint64(m.KeyType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KVPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVPayload) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMemoriae(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMemoriae(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Typ != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMemoriae(dAtA, i, uint64(m.Typ))
	}
	if len(m.Sign) > 0 {
		for _, b := range m.Sign {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMemoriae(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChallengeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChallengeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChallengerPrivateKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMemoriae(dAtA, i, uint64(len(m.ChallengerPrivateKey)))
		i += copy(dAtA[i:], m.ChallengerPrivateKey)
	}
	if len(m.AcceptChallengerAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMemoriae(dAtA, i, uint64(len(m.AcceptChallengerAddress)))
		i += copy(dAtA[i:], m.AcceptChallengerAddress)
	}
	if len(m.DataPath) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMemoriae(dAtA, i, uint64(len(m.DataPath)))
		i += copy(dAtA[i:], m.DataPath)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChallengeResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChallengeResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChallengerID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMemoriae(dAtA, i, uint64(len(m.ChallengerID)))
		i += copy(dAtA[i:], m.ChallengerID)
	}
	if len(m.AcceptChallengerID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMemoriae(dAtA, i, uint64(len(m.AcceptChallengerID)))
		i += copy(dAtA[i:], m.AcceptChallengerID)
	}
	if len(m.UserID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMemoriae(dAtA, i, uint64(len(m.UserID)))
		i += copy(dAtA[i:], m.UserID)
	}
	if len(m.Proof) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMemoriae(dAtA, i, uint64(len(m.Proof)))
		i += copy(dAtA[i:], m.Proof)
	}
	if m.Success {
		dAtA[i] = 0x28
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Blocks) > 0 {
		for _, s := range m.Blocks {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Random != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMemoriae(dAtA, i, uint64(m.Random))
	}
	dAtA[i] = 0x42
	i++
	i = encodeVarintMemoriae(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.Time)))
	n1, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Time, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Payment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMemoriae(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.StartTime)))
	n2, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.StartTime, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x12
	i++
	i = encodeVarintMemoriae(dAtA, i, uint64(github_com_gogo_protobuf_types.SizeOfStdTime(m.EndTime)))
	n3, err := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.EndTime, dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.Sum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMemoriae(dAtA, i, uint64(m.Sum))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintMemoriae(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Tx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovMemoriae(uint64(l))
	}
	if m.Typ != 0 {
		n += 1 + sovMemoriae(uint64(m.Typ))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovMemoriae(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovMemoriae(uint64(l))
	}
	if m.KeyType != 0 {
		n += 1 + sovMemoriae(uint64(m.KeyType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KVPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMemoriae(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMemoriae(uint64(l))
	}
	if m.Typ != 0 {
		n += 1 + sovMemoriae(uint64(m.Typ))
	}
	if len(m.Sign) > 0 {
		for _, b := range m.Sign {
			l = len(b)
			n += 1 + l + sovMemoriae(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChallengeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChallengerPrivateKey)
	if l > 0 {
		n += 1 + l + sovMemoriae(uint64(l))
	}
	l = len(m.AcceptChallengerAddress)
	if l > 0 {
		n += 1 + l + sovMemoriae(uint64(l))
	}
	l = len(m.DataPath)
	if l > 0 {
		n += 1 + l + sovMemoriae(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChallengeResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChallengerID)
	if l > 0 {
		n += 1 + l + sovMemoriae(uint64(l))
	}
	l = len(m.AcceptChallengerID)
	if l > 0 {
		n += 1 + l + sovMemoriae(uint64(l))
	}
	l = len(m.UserID)
	if l > 0 {
		n += 1 + l + sovMemoriae(uint64(l))
	}
	l = len(m.Proof)
	if l > 0 {
		n += 1 + l + sovMemoriae(uint64(l))
	}
	if m.Success {
		n += 2
	}
	if len(m.Blocks) > 0 {
		for _, s := range m.Blocks {
			l = len(s)
			n += 1 + l + sovMemoriae(uint64(l))
		}
	}
	if m.Random != 0 {
		n += 1 + sovMemoriae(uint64(m.Random))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Time)
	n += 1 + l + sovMemoriae(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Payment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.StartTime)
	n += 1 + l + sovMemoriae(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.EndTime)
	n += 1 + l + sovMemoriae(uint64(l))
	if m.Sum != 0 {
		n += 1 + sovMemoriae(uint64(m.Sum))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMemoriae(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMemoriae(x uint64) (n int) {
	return sovMemoriae(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Tx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMemoriae
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMemoriae
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= (TxType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMemoriae
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMemoriae
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= (PkType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMemoriae(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMemoriae
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMemoriae
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMemoriae
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMemoriae
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typ", wireType)
			}
			m.Typ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typ |= (KVType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMemoriae
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = append(m.Sign, make([]byte, postIndex-iNdEx))
			copy(m.Sign[len(m.Sign)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMemoriae(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMemoriae
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChallengeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMemoriae
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChallengeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChallengeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengerPrivateKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMemoriae
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengerPrivateKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptChallengerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMemoriae
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptChallengerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMemoriae
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMemoriae(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMemoriae
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChallengeResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMemoriae
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChallengeResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChallengeResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMemoriae
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptChallengerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMemoriae
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptChallengerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMemoriae
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMemoriae
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proof = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMemoriae
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Random", wireType)
			}
			m.Random = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Random |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMemoriae
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Time, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMemoriae(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMemoriae
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Payment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMemoriae
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMemoriae
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.StartTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMemoriae
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.EndTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			m.Sum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMemoriae(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMemoriae
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMemoriae(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMemoriae
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMemoriae
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMemoriae
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMemoriae
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMemoriae(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMemoriae = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMemoriae   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("memoriae.proto", fileDescriptor_memoriae_1593a725c8671815) }

var fileDescriptor_memoriae_1593a725c8671815 = []byte{
	// 612 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0xcd, 0x26, 0x69, 0x12, 0x4f, 0x43, 0xb1, 0x96, 0x0a, 0xac, 0x08, 0xa5, 0x51, 0x04, 0x52,
	0x54, 0xa9, 0xae, 0x1a, 0x54, 0x54, 0x2e, 0x48, 0x0d, 0xe9, 0xa1, 0x8a, 0x90, 0xa2, 0x8d, 0xc9,
	0x15, 0x6d, 0xec, 0xad, 0x6b, 0xd5, 0xf6, 0xba, 0xf6, 0x1a, 0x35, 0x7f, 0xc1, 0x0d, 0x0e, 0x48,
	0xdc, 0xf9, 0x92, 0x1e, 0xf9, 0x02, 0x40, 0xe5, 0x47, 0xd0, 0xee, 0xc6, 0x75, 0x41, 0xe1, 0xd0,
	0xdb, 0xbc, 0x79, 0xb3, 0x6f, 0xdf, 0xcc, 0xce, 0xc2, 0x56, 0xc4, 0x22, 0x9e, 0x06, 0x94, 0xd9,
	0x49, 0xca, 0x05, 0xc7, 0x9b, 0x05, 0x7e, 0x9f, 0x2c, 0x3a, 0x3b, 0x3e, 0xe7, 0x7e, 0xc8, 0xf6,
	0x15, 0xb5, 0xc8, 0xcf, 0xf6, 0x45, 0x10, 0xb1, 0x4c, 0xd0, 0x28, 0xd1, 0xd5, 0x9d, 0x3d, 0x3f,
	0x10, 0xe7, 0xf9, 0xc2, 0x76, 0x79, 0xb4, 0xef, 0x73, 0x9f, 0x97, 0x95, 0x12, 0x29, 0xa0, 0x22,
	0x5d, 0xde, 0xff, 0x86, 0xa0, 0xea, 0x5c, 0x61, 0x0b, 0x9a, 0x53, 0xba, 0x0c, 0x39, 0xf5, 0x2c,
	0xd4, 0x43, 0x83, 0x36, 0x29, 0x20, 0x7e, 0x0e, 0x35, 0x67, 0x99, 0x58, 0xd5, 0x1e, 0x1a, 0x6c,
	0x0d, 0x1f, 0xd9, 0x77, 0xbc, 0xd8, 0xce, 0x95, 0xb3, 0x4c, 0x18, 0x91, 0x3c, 0x7e, 0x0a, 0xc6,
	0x2c, 0xf0, 0x63, 0x2a, 0xf2, 0x94, 0x59, 0x35, 0x25, 0x51, 0x26, 0xf0, 0x63, 0x68, 0x4c, 0xf3,
	0xc5, 0x84, 0x2d, 0xad, 0xba, 0xa2, 0x56, 0x08, 0xef, 0x41, 0x73, 0xc2, 0x96, 0x52, 0xc5, 0xda,
	0x58, 0x73, 0xc1, 0xf4, 0x42, 0x5d, 0x50, 0xd4, 0xf4, 0x63, 0x30, 0x26, 0xf3, 0xc2, 0x98, 0x09,
	0x35, 0x29, 0xa8, 0xed, 0xca, 0x10, 0x6f, 0xc3, 0xc6, 0x9c, 0x86, 0x39, 0x53, 0x66, 0xdb, 0x44,
	0x83, 0xa2, 0x81, 0xda, 0x1a, 0xfd, 0xc9, 0xbc, 0x6c, 0x00, 0x43, 0x5d, 0xfa, 0xb5, 0xea, 0xbd,
	0xda, 0xa0, 0x4d, 0x54, 0xdc, 0xff, 0x82, 0xc0, 0x7c, 0x73, 0x4e, 0xc3, 0x90, 0xc5, 0x3e, 0x23,
	0xec, 0x32, 0x67, 0x99, 0xc0, 0x43, 0xd8, 0xbe, 0xcd, 0xa5, 0xd3, 0x34, 0xf8, 0x40, 0x05, 0x2b,
	0x8c, 0x18, 0x64, 0x2d, 0x87, 0x8f, 0xe0, 0xc9, 0xb1, 0xeb, 0xb2, 0x44, 0x94, 0xec, 0xb1, 0xe7,
	0xa5, 0x2c, 0xcb, 0x94, 0x57, 0x83, 0xfc, 0x8f, 0xc6, 0x1d, 0x68, 0x8d, 0xa9, 0xa0, 0x53, 0x2a,
	0xce, 0x55, 0x0b, 0x06, 0xb9, 0xc5, 0xfd, 0x4f, 0x55, 0x78, 0x78, 0xc7, 0x5e, 0x96, 0x87, 0x02,
	0xf7, 0xa1, 0x5d, 0x8a, 0x9c, 0x8e, 0x57, 0xae, 0xfe, 0xca, 0x61, 0x1b, 0xf0, 0xbf, 0xd7, 0x9d,
	0x8e, 0x57, 0x46, 0xd6, 0x30, 0xf2, 0xf5, 0xde, 0x65, 0xaa, 0x46, 0x3b, 0x58, 0x21, 0x39, 0xef,
	0x69, 0xca, 0xf9, 0x99, 0x7a, 0x54, 0x83, 0x68, 0x20, 0x57, 0x69, 0x96, 0xbb, 0xae, 0xec, 0x4d,
	0xbe, 0x69, 0x8b, 0x14, 0x50, 0xea, 0x8c, 0x42, 0xee, 0x5e, 0x64, 0x56, 0xa3, 0x57, 0x93, 0x3a,
	0x1a, 0xc9, 0x3c, 0xa1, 0xb1, 0xc7, 0x23, 0xab, 0xd9, 0x43, 0x83, 0x0d, 0xb2, 0x42, 0xf8, 0x08,
	0xea, 0x4e, 0x10, 0x31, 0xab, 0xd5, 0x43, 0x83, 0xcd, 0x61, 0xc7, 0xd6, 0xab, 0x6f, 0x17, 0x0b,
	0x6d, 0x3b, 0xc5, 0xea, 0x8f, 0x5a, 0xd7, 0x3f, 0x76, 0x2a, 0x1f, 0x7f, 0xee, 0x20, 0xa2, 0x4e,
	0xf4, 0xbf, 0x22, 0xb5, 0xcf, 0x11, 0x8b, 0x05, 0x1e, 0x81, 0x31, 0x13, 0x34, 0x15, 0x4a, 0x0a,
	0xdd, 0x43, 0xaa, 0x3c, 0x86, 0x5f, 0x43, 0xf3, 0x24, 0xf6, 0x94, 0x42, 0xf5, 0x1e, 0x0a, 0xc5,
	0x21, 0xb9, 0xab, 0x59, 0x1e, 0xa9, 0xf1, 0xd5, 0x89, 0x0c, 0x77, 0x77, 0xa1, 0xa1, 0xbf, 0x0f,
	0x6e, 0x40, 0x75, 0x32, 0x37, 0x2b, 0x78, 0x13, 0x9a, 0x72, 0xea, 0x84, 0x5d, 0x9a, 0xa8, 0x04,
	0x99, 0x59, 0xdd, 0x7d, 0x06, 0x0d, 0xbd, 0xa9, 0x32, 0x3d, 0x66, 0x67, 0x34, 0x0f, 0x85, 0x59,
	0xc1, 0x0f, 0xc0, 0x50, 0x03, 0x7c, 0xcb, 0x04, 0x35, 0x91, 0xac, 0xd2, 0xff, 0x45, 0x12, 0x33,
	0xe6, 0x26, 0xc3, 0xc3, 0x97, 0x17, 0x07, 0x5a, 0xf8, 0xc4, 0x1b, 0x1e, 0x1e, 0x1e, 0xbc, 0x32,
	0xd1, 0xc8, 0xbc, 0xbe, 0xe9, 0xa2, 0xef, 0x37, 0x5d, 0xf4, 0xeb, 0xa6, 0x8b, 0x3e, 0xff, 0xee,
	0x56, 0x16, 0x0d, 0xd5, 0xc2, 0x8b, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xcd, 0xfb, 0x5a, 0x62,
	0x77, 0x04, 0x00, 0x00,
}
