package keeper

import (
	"math/big"
	"strings"

	"github.com/ethereum/go-ethereum/common"
	mpb "github.com/memoio/go-mefs/pb"
	"github.com/memoio/go-mefs/role"
	ds "github.com/memoio/go-mefs/source/go-datastore"
	"github.com/memoio/go-mefs/utils"
	"github.com/memoio/go-mefs/utils/address"
	"github.com/memoio/go-mefs/utils/metainfo"
	"github.com/memoio/go-mefs/utils/pos"
)

// handle pos add provider
func (k *Info) handlePosGet(km *metainfo.Key, val []byte, from string) {
	utils.MLogger.Info("handlePos Add provider: ", km.ToString())

	// add provider to upkeeping if it is not in upkeeping
	ops := km.GetOptions()
	if len(ops) < 1 {
		return
	}

	if pos.GetPosId() != ops[0] {
		utils.MLogger.Info("handlePosGet error! from!=km.mid")
	}

	gp := k.getGroupInfo(ops[0], km.GetMainID(), true)
	if gp == nil {
		return
	}

	pid := string(val)
	for _, proID := range gp.providers {
		if proID == pid {
			return
		}
	}

	err := k.ukAddProvider(ops[0], km.GetMainID(), pid)
	if err != nil {
		utils.MLogger.Info("handlePos Add provider err:", err)
	}
}

// handlePosAdd handles block_meta which is generated by pos
// value is
func (k *Info) handlePosAdd(km *metainfo.Key, metaValue []byte, from string) {
	utils.MLogger.Info("handlePosAdd: ", km.ToString())
	ops := km.GetOptions()
	if len(ops) < 1 {
		return
	}

	if pos.GetPosId() != ops[0] {
		utils.MLogger.Info("handlePosAdd error! from!=km.mid")
		return
	}

	gp := k.getGroupInfo(ops[0], km.GetMainID(), true)
	if gp == nil {
		return
	}

	gp.loadContracts(true)

	blocks := strings.Split(string(metaValue), metainfo.DELIMITER)
	for _, boff := range blocks {
		blockID, off, err := metainfo.GetBidAndOffset(boff)
		if err != nil {
			continue
		}

		err = k.addBlockMeta(km.GetMainID(), blockID, from, off, true)
		if err != nil {
			continue
		}
	}
}

// handlePosDelete() handles pos block_meta deletion
func (k *Info) handlePosDelete(km *metainfo.Key, metaValue []byte, from string) {
	utils.MLogger.Info("handlePosDelete: ", km.ToString())
	ops := km.GetOptions()
	if len(ops) < 1 {
		return
	}

	if pos.GetPosId() != ops[0] {
		utils.MLogger.Info("handlePosDelete error!")
	}

	deleteBlocks := strings.Split(string(metaValue), metainfo.DELIMITER)
	for _, blockID := range deleteBlocks {
		//先删除本地信息
		kmBlock, err := metainfo.NewKey(blockID, mpb.KeyType_BlockPos)
		if err != nil {
			continue
		}
		err = k.ds.DeleteKey(k.context, kmBlock.ToString(), "local")
		if err != nil && err != ds.ErrNotFound {
			continue
		}
		//再删除内存中信息
		bm, err := metainfo.NewBlockFromString(blockID)
		if err != nil {
			continue
		}
		k.deleteBlockMeta(bm.GetQid(), blockID, false)
	}
}

func getPosPreIncome(ukAddrs []common.Address, localAddr common.Address) *big.Int {
	posPreIncome := big.NewInt(0)
	localID, err := address.GetIDFromAddress(localAddr.Hex())
	if err != nil {
		utils.MLogger.Debug("getIDFromAddress err: ", err, "address: ", localAddr.Hex())
		return posPreIncome
	}

	for _, ukAddr := range ukAddrs {
		ukID, err := address.GetIDFromAddress(ukAddr.Hex())
		if err != nil {
			utils.MLogger.Debug("getIDFromAddress err: ", err, "address: ", ukAddr.Hex())
			continue
		}
		ukItem, err := role.GetUpkeepingInfo(localID, ukID)
		if err != nil {
			utils.MLogger.Debug("GetUpkeepingInfo err: ", err, "localID: ", localID, "ukID: ", ukID)
			continue
		}
		for _, kInfo := range ukItem.Keepers {
			if kInfo.Addr.Hex() == localAddr.Hex() {
				posPreIncome.Add(posPreIncome, calculatePreIncome(kInfo.Money, int(kInfo.PayIndex.Int64())))
				break
			}
		}
	}
	return posPreIncome
}

func calculatePreIncome(money []*big.Int, payIndex int) *big.Int {
	count := big.NewInt(0)
	for ; payIndex < len(money); payIndex++ {
		count.Add(count, money[payIndex])
	}
	return count
}
